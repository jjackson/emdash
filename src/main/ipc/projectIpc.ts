import { ipcMain, dialog } from 'electron';
import { join } from 'path';
import * as fs from 'fs';
import { getMainWindow } from '../app/window';
import { errorTracking } from '../errorTracking';
import { wslExec as execAsync } from '../utils/wslPath';
const DEFAULT_REMOTE = 'origin';
const DEFAULT_BRANCH = 'main';

const normalizeRemoteName = (remote?: string | null) => {
  if (!remote) return DEFAULT_REMOTE;
  const trimmed = remote.trim();
  if (!trimmed) return ''; // Empty string indicates no remote (local-only repo)
  if (/^[A-Za-z0-9._-]+$/.test(trimmed) && !trimmed.includes('://')) {
    return trimmed;
  }
  return DEFAULT_REMOTE;
};

const computeBaseRef = (remote?: string | null, branch?: string | null) => {
  const remoteName = normalizeRemoteName(remote);
  if (branch && branch.trim().length > 0) {
    const trimmed = branch.trim();
    if (trimmed.includes('/')) return trimmed;
    // Prepend remote only if one exists
    return remoteName ? `${remoteName}/${trimmed}` : trimmed;
  }
  // Default: use origin/main if remote exists, otherwise just 'main'
  return remoteName ? `${remoteName}/${DEFAULT_BRANCH}` : DEFAULT_BRANCH;
};

const detectDefaultBranch = async (projectPath: string, remote?: string | null) => {
  const remoteName = normalizeRemoteName(remote);
  // If no remote, try to detect the current local branch
  if (!remoteName) {
    try {
      const { stdout } = await execAsync('git branch --show-current', {
        cwd: projectPath,
      });
      return stdout.trim() || null;
    } catch {
      return null;
    }
  }
  // Try to get remote's default branch
  try {
    const { stdout } = await execAsync(`git remote show ${remoteName}`, {
      cwd: projectPath,
    });
    const match = stdout.match(/HEAD branch:\s*(\S+)/);
    return match ? match[1] : null;
  } catch {
    return null;
  }
};

export function registerProjectIpc() {
  ipcMain.handle('project:open', async () => {
    try {
      const result = await dialog.showOpenDialog(getMainWindow()!, {
        title: 'Open Project',
        properties: ['openDirectory'],
        message: 'Select a project directory to open',
      });

      if (result.canceled || result.filePaths.length === 0) {
        return { success: false, error: 'No directory selected' };
      }

      const projectPath = result.filePaths[0];
      return { success: true, path: projectPath };
    } catch (error) {
      console.error('Failed to open project:', error);

      // Track project open errors
      await errorTracking.captureProjectError(error, 'open');

      return { success: false, error: 'Failed to open project directory' };
    }
  });

  ipcMain.handle('git:getInfo', async (_, projectPath: string) => {
    try {
      const resolveRealPath = async (target: string) => {
        try {
          return await fs.promises.realpath(target);
        } catch {
          return target;
        }
      };

      const resolvedProjectPath = await resolveRealPath(projectPath);
      const gitPath = join(resolvedProjectPath, '.git');
      const isGitRepo = fs.existsSync(gitPath);

      if (!isGitRepo) {
        return { isGitRepo: false, path: resolvedProjectPath };
      }

      // Get remote URL
      let remote: string | null = null;
      try {
        const { stdout } = await execAsync('git remote get-url origin', {
          cwd: resolvedProjectPath,
        });
        remote = stdout.trim();
      } catch {}

      // Get current branch
      let branch: string | null = null;
      try {
        const { stdout } = await execAsync('git branch --show-current', {
          cwd: resolvedProjectPath,
        });
        branch = stdout.trim();
      } catch {}

      let defaultBranch: string | null = null;
      if (!branch) {
        defaultBranch = await detectDefaultBranch(resolvedProjectPath, remote);
      }

      let upstream: string | null = null;
      let aheadCount: number | null = null;
      let behindCount: number | null = null;
      try {
        const { stdout } = await execAsync('git rev-parse --abbrev-ref --symbolic-full-name @{u}', {
          cwd: resolvedProjectPath,
        });
        upstream = stdout.trim();
      } catch {}

      if (upstream) {
        try {
          const { stdout } = await execAsync('git rev-list --left-right --count HEAD...@{u}', {
            cwd: resolvedProjectPath,
          });
          const [ahead, behind] = stdout.trim().split(/\s+/);
          aheadCount = Number.parseInt(ahead, 10);
          behindCount = Number.parseInt(behind, 10);
        } catch {}
      }

      let rootPath: string | null = null;
      try {
        const { stdout } = await execAsync('git rev-parse --show-toplevel', {
          cwd: resolvedProjectPath,
        });
        const trimmed = stdout.trim();
        if (trimmed) {
          rootPath = await resolveRealPath(trimmed);
        }
      } catch {}

      const baseRef = computeBaseRef(remote, branch || defaultBranch);

      const safeAhead =
        typeof aheadCount === 'number' && Number.isFinite(aheadCount) ? aheadCount : undefined;
      const safeBehind =
        typeof behindCount === 'number' && Number.isFinite(behindCount) ? behindCount : undefined;

      return {
        isGitRepo: true,
        remote,
        branch,
        baseRef,
        upstream,
        aheadCount: safeAhead,
        behindCount: safeBehind,
        path: resolvedProjectPath,
        rootPath: rootPath || resolvedProjectPath,
      };
    } catch (error) {
      console.error('Failed to get Git info:', error);
      return { isGitRepo: false, error: 'Failed to read Git information', path: projectPath };
    }
  });
}
